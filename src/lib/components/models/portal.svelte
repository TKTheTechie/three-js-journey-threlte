<!--
Auto-generated by: https://github.com/threlte/threlte/tree/main/packages/gltf
Command: npx @threlte/gltf@2.0.1 -u -P -k -K -s -o -D ./portal.glb
-->

<script context="module" lang="ts">
	import { Color, Group, ShaderMaterial } from 'three';
	import { T, forwardEventHandlers, useFrame } from '@threlte/core';
	import { useGltf, useSuspense, useTexture } from '@threlte/extras';
	import portalVertexShader from '../../../shaders/portal/vertex.glsl?raw';
	import portalFragmentShader from '../../../shaders/portal/fragment.glsl?raw';

	const loadModel = () => {
		const suspend = useSuspense();
		return suspend(useGltf('/models/portal.glb'));
	};

	const loadTexture = () => {
		const suspend = useSuspense();
		return suspend(useTexture('/models/baked.jpg'));
	};

	export const preload = async () => {
		await Promise.all([loadModel(), loadTexture()]);
	};
</script>

<script lang="ts">
	let portalMaterial: ShaderMaterial;

	export const ref = new Group();

	const gltf = loadModel();

	const texture = loadTexture();

	const component = forwardEventHandlers();

	const { start, stop, started } = useFrame(
		(ctx, deltaTime) => {
			if (portalMaterial) portalMaterial.uniforms.uTime.value += deltaTime;
		},
		{ autostart: true }
	);
</script>

<T is={ref} dispose={false} {...$$restProps} bind:this={$component}>
	{#await Promise.all([gltf, texture])}
		<slot name="fallback" />
	{:then [gltf, texture]}
		<T.Group name="Scene">
			<T.Mesh
				name="poleLightA"
				castShadow
				receiveShadow
				geometry={gltf.nodes.poleLightA.geometry}
				position={[0.71, 1.07, 0.23]}
			>
				<T.MeshBasicMaterial color="#ffffe5" />
			</T.Mesh>
			<T.Mesh
				name="portalLight"
				castShadow
				receiveShadow
				geometry={gltf.nodes.portalLight.geometry}
				position={[0, 0.85, -1.77]}
				rotation={[Math.PI / 2, 0, 0]}
			>
				<T.ShaderMaterial
					bind:ref={portalMaterial}
					vertexShader={portalVertexShader}
					fragmentShader={portalFragmentShader}
					uniforms={{
						uTime: { value: 0 },
						uColorStart: { value: new Color('#ffffff') },
						uColorEnd: { value: new Color('#000000') }
					}}
				/>
			</T.Mesh>
			<T.Mesh
				name="poleLightB"
				castShadow
				receiveShadow
				geometry={gltf.nodes.poleLightB.geometry}
				position={[-0.64, 1.07, 0.23]}
				rotation={[Math.PI, 0, Math.PI]}
			>
				<T.MeshBasicMaterial color="#ffffe5" />
			</T.Mesh>
			<T.Mesh
				name="baked"
				castShadow
				receiveShadow
				geometry={gltf.nodes.baked.geometry}
				material={gltf.nodes.baked.material}
			>
				<T.MeshBasicMaterial map={texture} map.flipY={false} />
			</T.Mesh>
		</T.Group>
	{:catch error}
		<slot name="error" {error} />
	{/await}

	<slot {ref} />
</T>
