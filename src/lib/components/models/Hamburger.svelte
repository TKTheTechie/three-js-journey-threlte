<!--
Auto-generated by: https://github.com/threlte/threlte/tree/main/packages/gltf
Command: npx @threlte/gltf@2.0.1 -h -u -P -k -K -s ../../../../static/hamburger.glb
-->

<script context="module">
	import { Group } from 'three';
	import { T, forwardEventHandlers } from '@threlte/core';
	import { useGltf, useSuspense } from '@threlte/extras';

	const load = () => {
		const suspend = useSuspense();
		return suspend(useGltf('hamburger.glb'));
	};

	export const preload = async () => {
		await load();
	};
</script>

<script>
	import { AutoColliders, RigidBody, Collider } from '@threlte/rapier';

	export const ref = new Group();

	const gltf = load();

	const component = forwardEventHandlers();

	export let rigidBodyType = 'dynamic';

	export let position = [0, 0, 0];
</script>

<T is={ref} dispose={false} {...$$restProps} bind:this={$component}>
	{#await gltf}
		<slot name="fallback" />
	{:then gltf}
		<T.Group name="Scene" position={[position[0], position[1], position[2]]} castShadow>
			<AutoColliders shape={'convexHull'} restitution={0.2} friction={0}>
				<RigidBody type={rigidBodyType == 'dynamic' ? 'dynamic' : 'fixed'}>
					<!-- <T.Group position={[0, 3, 0]}>
					<Collider shape={'roundCylinder'} args={[0, 2.8, 3]} />
				</T.Group> -->
					<T.Mesh
						name="bottomBun"
						castShadow
						receiveShadow
						geometry={gltf.nodes.bottomBun.geometry}
						material={gltf.materials.BunMaterial}
					/>

					<T.Mesh
						name="meat"
						castShadow
						receiveShadow
						geometry={gltf.nodes.meat.geometry}
						material={gltf.materials.SteakMaterial}
						position={[0, 2.82, 0]}
					/>
					<T.Mesh
						name="cheese"
						castShadow
						receiveShadow
						geometry={gltf.nodes.cheese.geometry}
						material={gltf.materials.CheeseMaterial}
						position={[0, 3.04, 0]}
					/>

					<T.Mesh
						name="topBun"
						castShadow
						receiveShadow
						geometry={gltf.nodes.topBun.geometry}
						material={gltf.materials.BunMaterial}
						position={[0, 1.77, 0]}
					/>
				</RigidBody>
			</AutoColliders>
		</T.Group>
	{:catch error}
		<slot name="error" {error} />
	{/await}
	<slot {ref} />
</T>
